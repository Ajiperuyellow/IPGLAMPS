//---------------------------------------------
//provided by subversion
//---------------------------------------------
//$HeadURL: file:///home/bamps/svn/lib/branches/initialStateLib/src/configurationbase.cpp $
//$LastChangedDate: 2018-04-30 15:14:39 +0200 (Mo, 30. Apr 2018) $
//$LastChangedRevision: 2744 $
//$LastChangedBy: greif $
//---------------------------------------------
//---------------------------------------------


#include <iostream>
#include <fstream>
#include <math.h>
#include <vector>
#include <string>
#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/program_options.hpp>
#include <boost/regex.hpp>

#include "configurationbase.h"
#include "particleprototype.h"
#include "coupling.h"


using std::cout;
using std::endl;
using std::fstream;
using std::ios;
using std::string;
using std::vector;
namespace po = boost::program_options;


/**
 * The only constructor provided for this class. Defaults for all parameters are set in case there is no
 * input file or it cannot be read.
 */
configBase::configBase() :
  //---- program_options groups ----
  usage_information("usage information"),
  hidden_options("Hidden options"),
  general_options("General options"),
  simulation_parameters("Parameters for the BAMPS simulation"),
  output_options("Options for the output generated by the BAMPS simulation"),
  parameters23("Options for 2->3 processes in BAMPS simulations"),
  misc_options("Miscellaneous options"),
  hydroAnalysis_options("Hydro Analysis options"),
  crossSection_options("methods of cross section"), 
  heavy_quark_options("Heavy quark options in BAMPS simulations"),
  // ---- general options ----
  jobName("default"),
  seed(0),
  // ---- simulation parameters ---- 
  runtime(0.5),
  testparticles(1),
  N_light_flavors_input(3),
  N_heavy_flavors_input(0),
  couplingRunning(false),
  fixedCouplingValue( 0.3 ),
  maxRunningCoupling( 1.0 ),
  // ---- output options ----
  standardOutputDirectoryName("output"),
  // ---- 2->3 parameters ----
  I23onlineIntegration( false ),
  gluonFormationTimeTyp23( "bamps_org" ),
  matrixElement23( "GBimproved" ),
  matrixElement23_22qt( false ),
  md2_counter_term_in_I23( true ),
  fudge_factor_lpm_23( 1.0 ),
  interpolation23_mode( log_interpol ),
  kappa23LightPartons( 1.0 ),
  kappa23HeavyQuarks( 1.0 ),
  K23LightPartons( 1.0 ),
  K23HeavyQuarks( 1.0 ),
  // ---- miscellaneous options ----
  switch_22(true),
  switch_23(true),
  switch_32(true),
  Kfactor_light( 1.0 ),
  // ---- hydro analysis options ----  
  analyseForHydro(false),
  numberColumnForHydroX(1),
  numberColumnForHydroY(1),
  numberColumnForHydroZ(1), 
  numberColumnArrowForHydroX(1),
  numberColumnArrowForHydroY(1),
  numberColumnArrowForHydroZ(1),  
  NumberColumnMidRapForHydroX(),
  NumberColumnMidRapForHydroY(),
  NumberColumnMidRapForHydroZ(), 
  NumberColumnMidRapArrowForHydroX(),
  NumberColumnMidRapArrowForHydroY(),
  NumberColumnMidRapArrowForHydroZ(), 
  // ---- hydro simulation options ----  
  crossSectionMethod(csMethod_pQCD),
  isotropicCrossSection(false),
  inputCrossSectionValue(1.0),
  // ---- heavy quark options ----
  KggQQbar(1.0),
  KgQgQ(1.0),
  kappa_gQgQ(1.0),
  isotropicCrossSecGQ(false),
  constantCrossSecGQ(false),
  constantCrossSecValueGQ(10.0),
  Mcharm_input(1.3),
  Mbottom_input(4.6)
{
  // The default value of standardOutputDirectoryName is changed in case the computation is performed at the CSC
  // (Fuchs = "old" cluster, Loewe = new LOEWE CSC).
  // Note that a value that is explicitly given in the configuration file will override the name determined here!
  char * csc_check_fuchs = getenv("PBS_JOBID");
  char * csc_check_loewe = getenv("SLURM_JOB_ID");
  if( csc_check_fuchs != NULL )
  {
    string jobID( csc_check_fuchs );
    standardOutputDirectoryName = "/local/" + jobID;
  }
  else if( csc_check_loewe != NULL )
  {
   //WARNING FOR LOCAL SLURM REMOVE LOEWE CHECK
     string jobID( csc_check_loewe );
     standardOutputDirectoryName = "/local/" + jobID;
  }
  
  // populate the program_options::options_description groups with names and types of the possible parameters
  initializeProgramOptions();
}


/**
 * This provides the interface for the actual reading and processing of program options. It needs to be explicitly called
 * after an instance of the configPrototype class has been created.
 * 
 * @param[in] argc number of command line arguments, passed from the calling process
 * @param[in] argv[] command line arguments, passed from the calling processes
 */
void configBase::readAndProcessProgramOptions ( const int argc, char* argv[] )
{
  groupProgramOptions();
  readProgramOptions(argc, argv);
  processProgramOptions();
   
  checkOptionsForSanity();
  
  if( ParticlePrototype::N_heavy_flavor > 0 )
  {
    processHeavyQuarkOptions();
  }
  
  printUsedConfigurationParameters();
}


/**
 * This is the place where post-processing of values that have been stored in the boost::program_options::variables_map
 * should go. For example conversion from integer to enum types etc.
 */
void configBase::processProgramOptions()
{
  boost::filesystem::path outputDirectory( standardOutputDirectoryName );
  checkAndCreateOutputDirectory( outputDirectory );
  
  ParticlePrototype::set_N_light_flavor( N_light_flavors_input );
  ParticlePrototype::set_N_heavy_flavor( N_heavy_flavors_input );
  cout << "N_f = N_f_light_quarks + N_f_heavy_quarks = " << ParticlePrototype::N_light_flavor << " + " <<   ParticlePrototype::N_heavy_flavor << endl;
  coupling::set_Nflavor( N_light_flavors_input );
  
  coupling::set_isRunning( couplingRunning );
  coupling::set_maxRunningCoupling( maxRunningCoupling );
  
  bool fixedCouplingValue_set = false;
  if( !( vm["simulation.fixed_Coupling"].defaulted() || vm["simulation.fixed_Coupling"].empty() ) )
  {
    fixedCouplingValue_set = true;
  }
  
  if ( !couplingRunning )
  {
    coupling::set_fixedCoupling( fixedCouplingValue );
    cout << "Fixed coupling constant to alpha_s = " << coupling::get_constant_coupling() << endl;
  }
  else if ( couplingRunning && !fixedCouplingValue_set )
  {
    cout << "Using running coupling with as_Max = " << coupling::get_maximum_coupling() << "..." << endl;
  }
  else
  {
    string errMsg = "Both fixed coupling constant value and running coupling are set. Do not know which one to use.";
    throw eConfig_error( errMsg );
  }
  
 //-------------------------------------//
  if ( vm.count("crossSection.crossSectionMethod") )
  {
    if ( vm["crossSection.crossSectionMethod"].as<int>() < 7 && vm["crossSection.crossSectionMethod"].as<int>() >= 0 )
    {
      crossSectionMethod = static_cast<CROSS_SECTION_METHOD>( vm["crossSection.crossSectionMethod"].as<int>() );
    }
    else
    {
      string errMsg = "parameter \"crossSection.crossSectionMethod\" out of range";
      throw eConfig_error( errMsg );
    }
  }  
  
 //-------------------------------------//
  if( crossSectionMethod != csMethod_pQCD )
  {
    switch_23 = false;
    switch_32 = false;
    isotropicCrossSection = true;
    cout << "WARNING: Non pQCD-cross sections are used! Used cross section method = " << crossSectionMethod << endl;
  } 
 //-------------------------------------//
 
  
 //-------------------------------------//
  if ( !switch_22 )
  {
    cout << "WARNING: 2->2 interactions switched OFF" << endl;
  }
  if ( !switch_23 )
  {
    cout << "WARNING: 2->3 interactions switched OFF" << endl;
  }
  if ( !switch_32 )
  {
    cout << "WARNING: 3->2 interactions switched OFF" << endl;
  }
  if ( !switch_22 && !switch_23 && !switch_32 )
  {
    std::string errMsg("ERROR: All interactions have been switched off");
    throw eConfig_error( errMsg );
  }
  
  if ( vm.count("parameters23.interpolation23_mode") )
  {
    if ( vm["parameters23.interpolation23_mode"].as<int>() < 3 && vm["parameters23.interpolation23_mode"].as<int>() >= 0 )
    {
      interpolation23_mode = static_cast<INTERPOLATION_MODE>( vm["parameters23.interpolation23_mode"].as<int>() );
    }
    else
    {
      string errMsg = "parameters23.interpolation23_mode\" out of range";
      throw eConfig_error( errMsg );      
    }
  }

  if ( isotropicCrossSection )
  {
    cout << "WARNING: Isotropic sampling of out-going particle momenta" << endl;;
  }
  
  if ( Kfactor_light != 1.0 )
  {
    cout << "WARNING: Kfactor for light parton processes = " << Kfactor_light << endl;
  }
}


/**
 * This routine is provided in case future implementations should contain sanity checks for the given values of parameters and
 * options.
 */
void configBase::checkOptionsForSanity()
{
  // sanity checks of parameters and options can go here  
  
  if( matrixElement23 != "GBimproved" && matrixElement23 != "GBorg" && matrixElement23 != "KPRapprox" )
  {
    string errMsg = "Value for matrixElement23 is not valid.";
    throw eConfig_error( errMsg );      
  }

  // check if parameters23.matrixElement23_22qt is set in input file: if not default value or no value given (latter happens if no input file is given at all)
  if ( !( vm["parameters23.matrixElement23_22qt"].defaulted() || vm["parameters23.matrixElement23_22qt"].empty() ) && matrixElement23 != "GBimproved" )
  {
    string errMsg = "Option matrixElement23_22qt can only be set if matrixElement23 = GBimproved.";
    throw eConfig_error( errMsg );      
  }
  

  if( gluonFormationTimeTyp23 != "bamps_org" && gluonFormationTimeTyp23 != "bamps_org_extended" && gluonFormationTimeTyp23 != "bamps_org_extended_xwE" )
  {
    string errMsg = "Value for gluonFormationTimeTyp23 is not valid.";
    throw eConfig_error( errMsg );      
  }

  if ( Kfactor_light != 1.0 && crossSectionMethod != csMethod_pQCD )
  {
    std::string errMsg("ERROR: K-factor scaling for light parton processes is only allowed for pQCD cross sections");
    throw eConfig_error( errMsg );
  }
  
  if ( crossSectionMethod != csMethod_pQCD && ( vm["crossSection.inputCrossSectionValue"].defaulted() || vm["crossSection.inputCrossSectionValue"].empty() ) )
  {
    std::string errMsg("ERROR: For using non-pQCD method value for cross section has to be set");
    throw eConfig_error( errMsg );
  }
}


/**
 * This routine initializes the boost::program_options::options_description objects that give structure to the handling of
 * user provided input.
 * By using a name pattern <group_name>.<option_name> the options can be given in a configuration file in INI format using 
 * group names such as
 * [group_name]
 * option_name1 = value1
 * option_name2 = value2
 */
void configBase::initializeProgramOptions()
{
  // Define some option groups. This gives more structure to the code and also structures the help message that is displayed
  // to the user.
  
  // Usage information. This is meant for the command line.
  usage_information.add_options()
  ("help,h", "print help message")
  ("detailed-help,d", "print detailed information on all options and parameters");
  
  // Read the name of the configuration file (from the command line)
  hidden_options.add_options()
  ("config-file,c", po::value< string >(), "configuration file");
  
  // Make "config-file" a positional option, i.e. it can be used without explicitly specifying "--config-file=blabla.txt"
  pos_options.add("config-file", 1);
  
  // Group some general options  
  general_options.add_options()
  ("general.jobname", po::value< string >( &jobName )->default_value( jobName ), "name of the simulation job, assigned to output files")
  ("general.seed", po::value<long>( &seed )->default_value( seed ), "inital seed for random number generator (0 = pick random seed)")
  ;
  
  // Group some simulation parameters
  simulation_parameters.add_options()
  ("simulation.time", po::value<double>( &runtime )->default_value( runtime ), "simulated time of the system evolution (fm/c)")
  ("simulation.N_test", po::value<double>( &testparticles )->default_value( testparticles ), "number of test particles per real parton")
  ("simulation.Nf_light", po::value<int>( &N_light_flavors_input )->default_value( N_light_flavors_input ), "number of light quark flavors")
  ("simulation.Nf_heavy", po::value<int>( &N_heavy_flavors_input )->default_value( N_heavy_flavors_input ), "number of heavy quark flavors")
  ("simulation.running_coupling", po::value<bool>( &couplingRunning )->default_value( couplingRunning ), "Running coupling for all processes")
  ("simulation.fixed_Coupling", po::value<double>( &fixedCouplingValue )->default_value( fixedCouplingValue ), "value of fixed coupling constant. Do not set when using running coupling.")
  ("simulation.maxRunningCoupling", po::value<double>( &maxRunningCoupling )->default_value( maxRunningCoupling ), "Maximum value of running coupling.")
  ;
  
  // Group some options related to the program output  
  output_options.add_options()
  ("output.directory", po::value<string>( &standardOutputDirectoryName )->default_value( standardOutputDirectoryName ), "directory to which general output should be written")
  ;
  
  // Group some options related to the 2->3 processes
  parameters23.add_options()
  ("parameters23.I23onlineIntegration", po::value<bool>( &I23onlineIntegration )->default_value( I23onlineIntegration ), "true if the integration of the total cross section for 2->3 processes is performed online and not read in from table")
  ("parameters23.gluonFormationTimeTyp23", po::value<string>( &gluonFormationTimeTyp23 )->default_value( gluonFormationTimeTyp23 ), "type of formation time of radiated gluon in 2->3 (e.g. bamps_org, bamps_org_extended, bamps_org_extended_xwE; infos in configurationbase.h)")
  ("parameters23.matrixElement23", po::value<string>( &matrixElement23 )->default_value( matrixElement23 ), "matrix element which is used for 2->3 scattering: GBimproved, GBorg, or KPRapprox")
  ("parameters23.matrixElement23_22qt", po::value<bool>( &matrixElement23_22qt )->default_value( matrixElement23_22qt ), "whether the gluon propagator in the 2->2 part of the radiative cross section is approximated by 1/qt^4. If false the more exact expression 1/t^2 is employed. Applies only to matrixElement23 = GBimproved. For GBorg always the approximated propagator is used. ATTENTION: Per default this parameter - even if set here - is not used in the routines. To activate it, call also interpolation23 and scattering23 with theConfig.isMatrixElement23_22qt()")
  ("parameters23.md2_counter_term_in_I23", po::value<bool>( &md2_counter_term_in_I23 )->default_value( md2_counter_term_in_I23 ), "whether a counter term is applied which resembles the old prescription of Xu for masssless particles")
  ("parameters23.fudge_factor_lpm_23", po::value<double>( &fudge_factor_lpm_23 )->default_value( fudge_factor_lpm_23 ), "factor for LPM effect: cutoff k_t > X gamma / lambda")
  ("parameters23.interpolation23_mode", po::value<int>( )->default_value( interpolation23_mode ), "stores the mode of interpolation for 2->3: 0 - log interpol, 1 - linear interpol, 2 - mix both interpolation")
  ("parameters23.kappa23LightPartons", po::value<double>( &kappa23LightPartons )->default_value( kappa23LightPartons ), "Kappa for Debye screening for 2->3 process with only light partons")
  ("parameters23.kappa23HeavyQuarks", po::value<double>( &kappa23HeavyQuarks )->default_value( kappa23HeavyQuarks ), "Kappa for Debye screening for 2->3 process involving a heavy quark")
  ("parameters23.K23LightPartons", po::value<double>( &K23LightPartons )->default_value( K23LightPartons ), "K factor to scale the total cross section for 2->3 process with only light partons")
  ("parameters23.K23HeavyQuarks", po::value<double>( &K23HeavyQuarks )->default_value( K23HeavyQuarks ), "K factor to scale the total cross section for 2->3 process involving a heavy quark")
  ;

  // Group miscellaneous options
  misc_options.add_options()
  ("misc.switch_22", po::value<bool>( &switch_22 )->default_value( switch_22 ), "switch 2->2 interactions on/off")
  ("misc.switch_23", po::value<bool>( &switch_23 )->default_value( switch_23 ), "switch 2->3 interactions on/off")
  ("misc.switch_32", po::value<bool>( &switch_32 )->default_value( switch_32 ), "switch 3->2 interactions on/off")
  ("misc.Kfactor_light", po::value<double>( &Kfactor_light )->default_value( Kfactor_light ), "K factor for light parton processes")
  ;

  // Add options for the hydro analysis
  hydroAnalysis_options.add_options()    
  ("hydro.analyseForHydro", po::value<bool>( &analyseForHydro )->default_value( analyseForHydro ), "switches the analysis on or off " )
  ("hydro.numberColumnForHydroX", po::value<int>( &numberColumnForHydroX )->default_value( numberColumnForHydroX ), "gives the number of the column for the hydro analysis in X direction " ) 
  ("hydro.numberColumnForHydroY", po::value<int>( &numberColumnForHydroY )->default_value( numberColumnForHydroY ), "gives the number of the column for the hydro analysis in Y direction " ) 
  ("hydro.numberColumnForHydroZ", po::value<int>( &numberColumnForHydroZ )->default_value( numberColumnForHydroZ ), "gives the number of the column for the hydro analysis in Z direction " ) 
  ("hydro.numberColumnArrowForHydroX", po::value<int>( &numberColumnArrowForHydroX )->default_value( numberColumnArrowForHydroX ), "gives the number of the arrow column for the hydro analysis in X directions " )
  ("hydro.numberColumnArrowForHydroY", po::value<int>( &numberColumnArrowForHydroY )->default_value( numberColumnArrowForHydroY ), "gives the number of the arrow column for the hydro analysis in Y directions " )   
  ("hydro.numberColumnArrowForHydroZ", po::value<int>( &numberColumnArrowForHydroZ )->default_value( numberColumnArrowForHydroZ ), "gives the number of the arrow column for the hydro analysis in Z directions " )  ;
  
  // Add options for the hydro calculations  
  crossSection_options.add_options() 
  ("crossSection.crossSectionMethod", po::value<int>()->default_value( static_cast<int>(crossSectionMethod) ), "choose the method for the cross section:\n  0 = \tpQCD (default)\n  1 = \tconstant cs\n  2 = \tconstant eta/s\n  3 = \tconstant mean free path\n  4 = \tconstant cross section for mixtures\n" )
  ("crossSection.isotropicCrossSection", po::value<bool>( &isotropicCrossSection )->default_value( isotropicCrossSection ), "set isotropic cross sections for all processes " )
  ("crossSection.inputCrossSectionValue", po::value<double>( &inputCrossSectionValue )->default_value( inputCrossSectionValue ), "depending on the method of cross section, you give the constant value of the cross section in [mb], constant eta/s or constant mean free path [fm] " )
  ;

  // Group heavy quark options
  heavy_quark_options.add_options()
  ("heavy_quark.charm_mass", po::value<double>( &Mcharm_input )->default_value( Mcharm_input ), "charm mass (GeV)")
  ("heavy_quark.bottom_mass", po::value<double>( &Mbottom_input )->default_value( Mbottom_input ), "bottom mass (GeV)")
  ("heavy_quark.Kfactor_ggQQbar", po::value<double>( &KggQQbar )->default_value( KggQQbar ), "K factor for process g + g -> Q + Qbar")
  ("heavy_quark.Kfactor_gQgQ", po::value<double>( &KgQgQ )->default_value( KgQgQ ), "K factor for process g + Q -> g + Q")
  ("heavy_quark.kappa_gQgQ", po::value<double>( &kappa_gQgQ )->default_value( kappa_gQgQ ), "multiplying factor kappa for the Debye mass in  g + Q -> g + Q processes")
  ("heavy_quark.iso_xsection_gQ", po::value<bool>( &isotropicCrossSecGQ )->default_value( isotropicCrossSecGQ ), "switch for isotropic cross section in g+Q -> g+Q processes")
  ("heavy_quark.const_xsection_gQ", po::value<bool>( &constantCrossSecGQ )->default_value( constantCrossSecGQ ), "switch for constant cross section for g+Q -> g+Q processes")
  ("heavy_quark.const_xsection_gQ_value", po::value<double>( &constantCrossSecValueGQ )->default_value( constantCrossSecValueGQ ), "value for constant g+Q -> g+Q cross section (mb)")
  ;
}


/**
 * This provides some special processing for options that are related to the handling of heavy quark flavors.
 */
void configBase::processHeavyQuarkOptions()
{
  ParticlePrototype::setCharmMass( Mcharm_input );
  cout << "Charm mass: " << ParticlePrototype::Mcharm;
  if( ParticlePrototype::N_heavy_flavor > 1 )
  {
    ParticlePrototype::setBottomMass( Mbottom_input );
    cout << "  bottom mass: " << ParticlePrototype::Mbottom;
  }
  cout << endl;
  
  if(constantCrossSecGQ)
  {
    cout << "Constant cross section of " << constantCrossSecValueGQ << " mb for gQ-> gQ." << endl;
  }
  else
  {
    cout << "pQCD cross section for gQ-> gQ with K = " << KgQgQ;
    if(couplingRunning)
    {
      cout << " and running coupling";
    }
    else
    {
      cout << " and constant coupling alpha_s = " << fixedCouplingValue;
    }
    cout << ", kappa_gQ = " << kappa_gQgQ << endl;
  }
  
  if(isotropicCrossSecGQ)
  {
    cout << "Sample angle isotropic for gQ-> gQ." << endl;
  }
}


/**
 * This routine groups the options_description groups into categories that can control which parameters are accessible via
 * the command line or the configuration file, which parameters are visible when requesting detailed help messages etc.
 */
void configBase::groupProgramOptions()
{ 
  // Group options that are meant to be provided via the command line
  command_line_options.add(usage_information).add(general_options).add(output_options).add(parameters23).add(hidden_options).add(misc_options).add(simulation_parameters);
  
  // Group options that are meant to be provided via a configuration file
  config_file_options.add(general_options).add(simulation_parameters).add(output_options).add(parameters23).add(misc_options).add(hydroAnalysis_options).add(crossSection_options).add(heavy_quark_options);
  
  // Group options that are to be printed in a detailed help message
  visible_options.add(usage_information).add(general_options).add(simulation_parameters).add(output_options).add(parameters23).add(misc_options).add(hydroAnalysis_options).add(crossSection_options).add(heavy_quark_options);
}


/**
 * This routine actually reads the parameters from the command line and the configuration file and stores them into 
 * the variable map. 
 */
void configBase::readProgramOptions( const int argc, char* argv[] )
{ 
  // parse the command line arguments
  po::store( po::command_line_parser(argc, argv).options(command_line_options).positional(pos_options).run(), vm );
  po::notify(vm); // needed to actually populate the map "vm" with all the argument values
  
  // check whether help messages are requested and print them
  if (vm.count("help"))
  {
    cout << "Usage: cascade [options] [configuration file]" << endl;
    cout << usage_information << "\n";
    throw( HELP_MESSAGE_REQUESTED );
  }
  if (vm.count("detailed-help"))
  {
    cout << "Usage: cascade [options] [configuration file]" << endl;
    cout << visible_options << "\n";
    throw( HELP_MESSAGE_REQUESTED );
  }
  
  // check whether a configuration file name has been provided and parse this file if applicable
  if ( vm.count("config-file") )
  {
    boost::filesystem::path configFileName( vm["config-file"].as< string >() );
    if ( boost::filesystem::exists( configFileName ) )
    {
      cout << "Using configuration from: " << vm["config-file"].as< string >() << endl;
      boost::filesystem::ifstream configFile( configFileName );
      po::store( po::parse_config_file(configFile, config_file_options), vm);
      po::notify(vm);
    }
    else
    {
      string errMsg = "Configuration file \"" + vm["config-file"].as< string >() + "\" could not be found.";
      throw eConfig_error( errMsg );
    }
  }
  else
  {
    // read a dummmy (i.e. non-existing) configuration file in case no real configuration file has been specified
    // this way the variable map vm gets to know about the options in the group config_file_options and the (default) 
    // values of the parameters can still be printed via configBase::printOptionsDescriptionToIniFormat
    boost::filesystem::ifstream configFile( "" );
    po::store( po::parse_config_file(configFile, config_file_options), vm);
  }
}


/**
 * This routine prints a given boost::program_options::options_description group to INI format that is used for configuration
 * files. The output is written to a given file stream.
 * 
 * @param[in] _desc The options_description group to be printed
 * @param[in] _file The file stream object to which the output is to be printed
 */
void configBase::printOptionsDescriptionToIniFormat( const boost::program_options::options_description& _desc, boost::filesystem::ofstream& _file )
{
  boost::regex re( "(\\w+)(\\.)(\\w+)" );
  boost::smatch matches;
  
  if ( _desc.options().size() > 0 )
  {
    boost::regex_match(_desc.options()[0]->long_name(),matches,re);
    _file << "[" << matches[1] << "]" << endl;
    
    for ( unsigned int i = 0; i < _desc.options().size(); i++ )
    {
      if ( boost::regex_match(_desc.options()[i]->long_name(),matches,re) )
      {
        _file << matches[3] << " = " << convertBoostAnyToString( vm[matches[0]] ) << endl;
      }
    }
    _file << endl;
  }
}


/**
 * boost::program_options internally stores the parameter values into boost::any datatypes that cannot be printed directly.
 * Therefore this routine provides explicit conversion of the values stored in boost::program_options::variable_value objects
 * to strings.
 * NOTE Unfortunately, due to limitations of boost::any, there is no generic way to do this. Therefore every datatype that occurs
 * in the program options needs to be explicitly checked here.
 * 
 * @param[in] _arg The boost::program_options::variable_value object whose value should be converted to string
 */
std::string configBase::convertBoostAnyToString ( const boost::program_options::variable_value& _arg )
{
  std::string result;
  if ( _arg.value().type() == typeid( int ) )
  {
    result = boost::lexical_cast<std::string,int>( _arg.as<int>() );
  }
  else if ( _arg.value().type() == typeid( unsigned int ) ) 
  {
    result = boost::lexical_cast<std::string,unsigned int>( _arg.as<unsigned int>() );
  }
  else if ( _arg.value().type() == typeid( long ) )
  {
    result = boost::lexical_cast<std::string,long>( _arg.as<long>() );
  }
  else if ( _arg.value().type() == typeid( unsigned short int ) )
  {
    result = boost::lexical_cast<std::string,unsigned short int>( _arg.as<unsigned short int>() );
  }
  else if ( _arg.value().type() == typeid( double ) )
  {
    result = boost::lexical_cast<std::string,double>( _arg.as<double>() );
  }
  else if ( _arg.value().type() == typeid( bool ) )
  {
    result = boost::lexical_cast<std::string,int>( static_cast<int>(_arg.as<bool>()) );  
  }
  else if ( _arg.value().type() == typeid( std::string ) )
  {
    result = _arg.as<std::string>();
  }
  else
  {
    std::string errMsg("configPrototype::convertBoostAnyToString: Unknown type, conversion failed.");
    throw eConfig_error( errMsg );
  }
  
  return result;
}


/**
 * Print a file in INI format with all current option values. This file could be used a configuration filename
 * in a subsequent run to reproduce the very same option settings.
 */
void configBase::printUsedConfigurationParameters()
{
  string filename = standardOutputDirectoryName + "/" + jobName + "_used_configuration";
  boost::filesystem::path outputFile( filename );
  boost::filesystem::ofstream output( outputFile, ios::trunc );
  
  printOptionsDescriptionToIniFormat( general_options, output );
  printOptionsDescriptionToIniFormat( simulation_parameters, output );
  printOptionsDescriptionToIniFormat( output_options, output );
  printOptionsDescriptionToIniFormat( parameters23, output );
  printOptionsDescriptionToIniFormat( misc_options, output );
  printOptionsDescriptionToIniFormat( hydroAnalysis_options, output );  
  printOptionsDescriptionToIniFormat( crossSection_options, output );    
  printOptionsDescriptionToIniFormat( heavy_quark_options, output );
}
